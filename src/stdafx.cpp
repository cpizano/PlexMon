// This is the plex precompiled header cc.
// Do not edit this file by hand.

#include "stdafx.h"



namespace plx {
ItRange<uint8_t*> RangeFromBytes(void* start, size_t count) {
  auto s = reinterpret_cast<uint8_t*>(start);
  return ItRange<uint8_t*>(s, s + count);
}
ItRange<const uint8_t*> RangeFromBytes(const void* start, size_t count) {
  auto s = reinterpret_cast<const uint8_t*>(start);
  return ItRange<const uint8_t*>(s, s + count);
}
ItRange<const uint8_t*> RangeFromString(const std::string& str) {
  auto s = reinterpret_cast<const uint8_t*>(&str.front());
  return ItRange<const uint8_t*>(s, s + str.size());
}
ItRange<uint8_t*> RangeFromString(std::string& str) {
  auto s = reinterpret_cast<uint8_t*>(&str.front());
  return ItRange<uint8_t*>(s, s + str.size());
}
ItRange<const uint16_t*> RangeFromString(const std::wstring& str) {
  auto s = reinterpret_cast<const uint16_t*>(&str.front());
  return ItRange<const uint16_t*>(s, s + str.size());
}
ItRange<uint16_t*> RangeFromString(std::wstring& str) {
  auto s = reinterpret_cast<uint16_t*>(&str.front());
  return ItRange<uint16_t*>(s, s + str.size());
}
plx::FilePath GetAppDataPath(bool roaming) {
  auto folder = roaming? FOLDERID_RoamingAppData : FOLDERID_LocalAppData;
  wchar_t* path = nullptr;
  auto hr = ::SHGetKnownFolderPath(folder, 0, nullptr, &path);
  if (hr != S_OK)
    throw plx::IOException(__LINE__, L"<appdata folder>");
  auto fp = FilePath(path);
  ::CoTaskMemFree(path);
  return fp;
}
char* HexASCII(uint8_t byte, char* out) {
  *out++ = HexASCIITable[(byte >> 4) & 0x0F];
  *out++ = HexASCIITable[byte & 0x0F];
  return out;
}
std::string HexASCIIStr(const plx::Range<const uint8_t>& r, char separator) {
  if (r.empty())
    return std::string();

  std::string str((r.size() * 3) - 1, separator);
  char* data = &str[0];
  for (size_t ix = 0; ix != r.size(); ++ix) {
    data = plx::HexASCII(r[ix], data);
    ++data;
  }
  return str;
}
short NextInt(char value) {
  return short(value);
}
int NextInt(short value) {
  return int(value);
}
long long NextInt(int value) {
  return long long(value);
}
long long NextInt(long value) {
  return long long(value);
}
long long NextInt(long long value) {
  return value;
}
short NextInt(unsigned char value) {
  return short(value);
}
int NextInt(unsigned short value) {
  return int(value);
}
long long NextInt(unsigned int value) {
  return long long(value);
}
long long NextInt(unsigned long value) {
  return long long(value);
}
long long NextInt(unsigned long long value) {
  if (static_cast<long long>(value) < 0LL)
    throw plx::OverflowException(__LINE__, plx::OverflowKind::Positive);
  return long long(value);
}
std::string DecodeString(plx::Range<const char>& range) {
  if (range.empty())
    return std::string();
  if (range[0] != '\"') {
    auto r = plx::RangeFromBytes(range.start(), 1);
    throw plx::CodecException(__LINE__, &r);
  }

  std::string s;
  for (;;) {
    auto text_start = range.start();
    while (range.advance(1) > 0) {
      auto c = range.front();
      if (c < 32) {
        throw plx::CodecException(__LINE__, nullptr);
      } else {
        switch (c) {
          case '\"' : break;
          case '\\' : goto escape;
          default: continue;
        }
      }
      s.append(++text_start, range.start());
      range.advance(1);
      return s;
    }
    // Reached the end of range before a (").
    throw plx::CodecException(__LINE__, nullptr);

  escape:
    s.append(++text_start, range.start());
    if (range.advance(1) <= 0)
      throw plx::CodecException(__LINE__, nullptr);

    switch (range.front()) {
      case '\"':  s.push_back('\"'); break;
      case '\\':  s.push_back('\\'); break;
      case '/':   s.push_back('/');  break;
      case 'b':   s.push_back('\b'); break;
      case 'f':   s.push_back('\f'); break;
      case 'n':   s.push_back('\n'); break;
      case 'r':   s.push_back('\r'); break;
      case 't':   s.push_back('\t'); break;   //$$ missing \u (unicode).
      default: {
        auto r = plx::RangeFromBytes(range.start() - 1, 2);
        throw plx::CodecException(__LINE__, &r);
      }
    }
  }
}
namespace JsonImp {
template <typename StrT>
bool Consume(plx::Range<const char>& r, StrT&& str) {
  auto c = r.starts_with(plx::RangeFromLitStr(str));
  if (c) {
    r.advance(c);
    return true;
  }
  else {
    return (c != 0);
  }
}

bool IsNumber(plx::Range<const char>&r) {
  if ((r.front() >= '0') && (r.front() <= '9'))
    return true;
  if ((r.front() == '-') || (r.front() == '+'))
    return true;
  if (r.front() == '.')
    return true;
  return false;
}

plx::JsonValue ParseArray(plx::Range<const char>& range) {
  if (range.empty())
    throw plx::CodecException(__LINE__, NULL);
  if (range.front() != '[')
    throw plx::CodecException(__LINE__, NULL);

  JsonValue value(plx::JsonType::ARRAY);
  range.advance(1);

  for (;!range.empty();) {
    range = plx::SkipWhitespace(range);

    if (range.front() == ',') {
      if (range.advance(1) <= 0)
        break;
      range = plx::SkipWhitespace(range);
    }

    if (range.front() == ']') {
      range.advance(1);
      return value;
    }

    value.push_back(ParseJsonValue(range));
  }

  auto r = plx::RangeFromBytes(range.start(), range.size());
  throw plx::CodecException(__LINE__, &r);
}

plx::JsonValue ParseNumber(plx::Range<const char>& range) {
  size_t pos = 0;
  auto num = plx::StringFromRange(range);

  auto iv = std::stoll(num, &pos);
  if ((range[pos] != 'e') && (range[pos] != 'E') && (range[pos] != '.')) {
    range.advance(pos);
    return iv;
  }

  auto dv = std::stod(num, &pos);
  range.advance(pos);
  return dv;
}

plx::JsonValue ParseObject(plx::Range<const char>& range) {
  if (range.empty())
    throw plx::CodecException(__LINE__, NULL);
  if (range.front() != '{')
    throw plx::CodecException(__LINE__, NULL);

  JsonValue obj(plx::JsonType::OBJECT);
  range.advance(1);

  for (;!range.empty();) {
    if (range.front() == '}') {
      range.advance(1);
      return obj;
    }

    range = plx::SkipWhitespace(range);
    auto key = plx::DecodeString(range);

    range = plx::SkipWhitespace(range);
    if (range.front() != ':')
      throw plx::CodecException(__LINE__, nullptr);
    if (range.advance(1) <= 0)
      throw plx::CodecException(__LINE__, nullptr);

    range = plx::SkipWhitespace(range);
    obj[key] = ParseJsonValue(range);

    range = plx::SkipWhitespace(range);
    if (range.front() == ',') {
      if (range.advance(1) <= 0)
        break;
      range = plx::SkipWhitespace(range);
    }
  }
  throw plx::CodecException(__LINE__, nullptr);
}

}
plx::JsonValue ParseJsonValue(plx::Range<const char>& range) {
  range = plx::SkipWhitespace(range);
  if (range.empty())
    throw plx::CodecException(__LINE__, NULL);

  if (range.front() == '{')
    return JsonImp::ParseObject(range);
  if (range.front() == '\"')
    return plx::DecodeString(range);
  if (range.front() == '[')
    return JsonImp::ParseArray(range);
  if (JsonImp::Consume(range, "true"))
    return true;
  if (JsonImp::Consume(range, "false"))
    return false;
  if (JsonImp::Consume(range, "null"))
    return nullptr;
  if (JsonImp::IsNumber(range))
    return JsonImp::ParseNumber(range);

  auto r = plx::RangeFromBytes(range.start(), range.size());
  throw plx::CodecException(__LINE__, &r);
}
namespace impl_v {
int vsnprintf(char* buffer, size_t size,
              const char* format, va_list arguments) {
  int length = _vsprintf_p(buffer, size, format, arguments);
  if (length < 0) {
    if (size > 0)
      buffer[0] = 0;
    return _vscprintf_p(format, arguments);
  }
  return length;
}
}
std::string StringPrintf(const char* fmt, ...) {
  int fmt_size = 128;
  std::unique_ptr<char> mem;

  va_list args;
  va_start(args, fmt);

  while (true) {
    mem.reset(new char[fmt_size]);
    int sz = impl_v::vsnprintf(mem.get(), fmt_size, fmt, args);
    if (sz < fmt_size)
      break;
    fmt_size = sz + 1;
  }

  va_end(args);
  return std::string(mem.get());
}
plx::JsonValue JsonFromFile(plx::File& cfile) {
  if (!cfile.is_valid())
    throw plx::IOException(__LINE__, L"<json file>");
  auto size = cfile.size_in_bytes();
  plx::Range<uint8_t> r(0, plx::To<size_t>(size));
  auto mem = plx::HeapRange(r);
  if (cfile.read(r, 0) != size)
    throw plx::IOException(__LINE__, L"<json file>");
  plx::Range<const char> json(reinterpret_cast<char*>(r.start()),
                              reinterpret_cast<char*>(r.end()));
  return plx::ParseJsonValue(json);
}
std::wstring UTF16FromUTF8(const plx::Range<const uint8_t>& utf8, bool strict) {
  if (utf8.empty())
      return std::wstring();
  // Get length and validate string.
  const int utf16_len = ::MultiByteToWideChar(
      CP_UTF8,  strict ? MB_ERR_INVALID_CHARS : 0,
      reinterpret_cast<const char*>(utf8.start()),
      plx::To<int>(utf8.size()),
      NULL,
      0);
  if (utf16_len == 0) {
    throw plx::CodecException(__LINE__, nullptr);
  }

  std::wstring utf16;
  utf16.resize(utf16_len);
  // Now do the conversion without validation.
  if (!::MultiByteToWideChar(
      CP_UTF8, 0,
      reinterpret_cast<const char*>(utf8.start()),
      plx::To<int>(utf8.size()),
      &utf16[0],
      utf16_len)) {
    throw plx::CodecException(__LINE__, nullptr);
  }
  return utf16;
}
}

// This is the plex precompiled header cc.
// Do not edit this file by hand.

#include "stdafx.h"



namespace plx {
char* HexASCII(uint8_t byte, char* out) {
  *out++ = HexASCIITable[(byte >> 4) & 0x0F];
  *out++ = HexASCIITable[byte & 0x0F];
  return out;
}
ItRange<uint8_t*> RangeFromBytes(void* start, size_t count) {
  auto s = reinterpret_cast<uint8_t*>(start);
  return ItRange<uint8_t*>(s, s + count);
}
ItRange<const uint8_t*> RangeFromBytes(const void* start, size_t count) {
  auto s = reinterpret_cast<const uint8_t*>(start);
  return ItRange<const uint8_t*>(s, s + count);
}
ItRange<const uint8_t*> RangeFromString(const std::string& str) {
  auto s = reinterpret_cast<const uint8_t*>(&str.front());
  return ItRange<const uint8_t*>(s, s + str.size());
}
ItRange<uint8_t*> RangeFromString(std::string& str) {
  auto s = reinterpret_cast<uint8_t*>(&str.front());
  return ItRange<uint8_t*>(s, s + str.size());
}
ItRange<const uint16_t*> RangeFromString(const std::wstring& str) {
  auto s = reinterpret_cast<const uint16_t*>(&str.front());
  return ItRange<const uint16_t*>(s, s + str.size());
}
ItRange<uint16_t*> RangeFromString(std::wstring& str) {
  auto s = reinterpret_cast<uint16_t*>(&str.front());
  return ItRange<uint16_t*>(s, s + str.size());
}
short NextInt(char value) {
  return short(value);
}
int NextInt(short value) {
  return int(value);
}
long long NextInt(int value) {
  return long long(value);
}
long long NextInt(long value) {
  return long long(value);
}
long long NextInt(long long value) {
  return value;
}
short NextInt(unsigned char value) {
  return short(value);
}
int NextInt(unsigned short value) {
  return int(value);
}
long long NextInt(unsigned int value) {
  return long long(value);
}
long long NextInt(unsigned long value) {
  return long long(value);
}
long long NextInt(unsigned long long value) {
  if (static_cast<long long>(value) < 0LL)
    throw plx::OverflowException(__LINE__, plx::OverflowKind::Positive);
  return long long(value);
}
std::string HexASCIIStr(const plx::Range<const uint8_t>& r, char separator) {
  if (r.empty())
    return std::string();

  std::string str((r.size() * 3) - 1, separator);
  char* data = &str[0];
  for (size_t ix = 0; ix != r.size(); ++ix) {
    data = plx::HexASCII(r[ix], data);
    ++data;
  }
  return str;
}
namespace impl_v {
int vsnprintf(char* buffer, size_t size,
              const char* format, va_list arguments) {
  int length = _vsprintf_p(buffer, size, format, arguments);
  if (length < 0) {
    if (size > 0)
      buffer[0] = 0;
    return _vscprintf_p(format, arguments);
  }
  return length;
}
}
std::string StringPrintf(const char* fmt, ...) {
  int fmt_size = 128;
  std::unique_ptr<char> mem;

  va_list args;
  va_start(args, fmt);

  while (true) {
    mem.reset(new char[fmt_size]);
    int sz = impl_v::vsnprintf(mem.get(), fmt_size, fmt, args);
    if (sz < fmt_size)
      break;
    fmt_size = sz + 1;
  }

  va_end(args);
  return std::string(mem.get());
}
std::wstring UTF16FromUTF8(const plx::Range<const uint8_t>& utf8, bool strict) {
  if (utf8.empty())
      return std::wstring();
  // Get length and validate string.
  const int utf16_len = ::MultiByteToWideChar(
      CP_UTF8,  strict ? MB_ERR_INVALID_CHARS : 0,
      reinterpret_cast<const char*>(utf8.start()),
      plx::To<int>(utf8.size()),
      NULL,
      0);
  if (utf16_len == 0) {
    throw plx::CodecException(__LINE__, nullptr);
  }

  std::wstring utf16;
  utf16.resize(utf16_len);
  // Now do the conversion without validation.
  if (!::MultiByteToWideChar(
      CP_UTF8, 0,
      reinterpret_cast<const char*>(utf8.start()),
      plx::To<int>(utf8.size()),
      &utf16[0],
      utf16_len)) {
    throw plx::CodecException(__LINE__, nullptr);
  }
  return utf16;
}
}
